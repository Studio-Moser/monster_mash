<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Monster Board Game - Prototype 7 (Loop)</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f5f5f5;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(4, 60px);
      grid-template-rows: repeat(4, 60px);
      gap: 5px;
      justify-content: center;
      margin: 20px auto;
      position: relative;
    }
    .cell {
      width: 60px;
      height: 60px;
      border: 1px solid #000;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      position: relative;
    }
    .cell .creature {
      display: inline-block;
      line-height: 1;
    }
    .cell .hover-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0.4;
      pointer-events: none;
    }
    .cell:hover {
      background-color: #f0f0f0;
    }
    .cell.checking {
      border: 3px solid #ffcc00;
      box-shadow: 0 0 10px #ffcc00;
    }
    .cell.match-found {
      animation: flash-match 0.5s;
    }
    @keyframes flash-match {
      0%, 100% { border-color: #000; }
      25%, 75% { border-color: #00ff00; border-width: 3px; box-shadow: 0 0 15px #00ff00; }
      50% { border-color: #000; }
    }
    .animated-piece {
      position: absolute;
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      pointer-events: none;
      z-index: 10;
      transition: all 0.3s ease-out;
    }
    .animated-piece .creature {
      display: inline-block;
      line-height: 1;
    }
    .size-human { font-size: 32px; }
    .size-fish { font-size: 26px; }
    .size-frog { font-size: 20px; }
    .size-mosquito { font-size: 14px; }
    .info {
      margin: 10px;
    }
    #next-piece {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 60px;
      min-height: 30px;
      vertical-align: middle;
    }
    .diagram {
      margin-top: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .multiplier-popup {
      position: absolute;
      font-size: 40px;
      font-weight: bold;
      color: #ff6b00;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      pointer-events: none;
      z-index: 20;
      animation: popup-float 1.5s ease-out forwards;
    }
    @keyframes popup-float {
      0% { transform: scale(0.5) translateY(0); opacity: 0; }
      20% { transform: scale(1.5) translateY(-10px); opacity: 1; }
      100% { transform: scale(1) translateY(-80px); opacity: 0; }
    }
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      pointer-events: none;
      z-index: 15;
      animation: confetti-fall 2s ease-out forwards;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(300px) rotate(720deg); opacity: 0; }
    }
  </style>
</head>
<body>
  <h1>Monster Board Game - Prototype 7</h1>
  <h3>Food Chain Loop</h3>
  <div class="info">
    <p>Score: <span id="score">0</span></p>
    <p>Next Piece: <span id="next-piece">...</span></p>
  </div>
  <div class="board" id="board"></div>
  <div class="diagram">
    <p><strong>Circular Food Chain - No Evolution!</strong></p>
    <p><span class="size-human">üßë</span> Human eats <span class="size-fish">üêü</span> Fish</p>
    <p><span class="size-fish">üêü</span> Fish eats <span class="size-frog">üê∏</span> Frog</p>
    <p><span class="size-frog">üê∏</span> Frog eats <span class="size-mosquito">ü¶ü</span> Mosquito</p>
    <p><span class="size-mosquito">ü¶ü</span> Mosquito kills <span class="size-human">üßë</span> Human (disease)</p>
    <p><strong>‚ö° Multi-Eat!</strong> Pieces eat ALL valid targets in a line!</p>
    <p><strong>üå™Ô∏è Direction Inheritance!</strong> After eating, pieces face the direction of their victim!</p>
    <p><strong>üíØ Chain Multiplier!</strong> 1 eat = 1 pt, 2 eats = 4 pts, 3 eats = 9 pts, 4 eats = 16 pts!</p>
    <p><span style="color: #999;">Longer chains = exponentially more points!</span></p>
    <p><strong>Actions:</strong> ‚Üª ‚Ü∫ (rotate in place), ‚Üë ‚Üí ‚Üì ‚Üê (move + rotate)</p>
  </div>
  <script>
    const boardSize = 4;
    const colors = ["üßë", "üêü", "üê∏", "ü¶ü"];
    const directions = ["‚Üë", "‚Üí", "‚Üì", "‚Üê"];
    const actions = ["‚Üª", "‚Ü∫", "‚Üë", "‚Üí", "‚Üì", "‚Üê"];
    const eatRules = { "üßë": "üêü", "üêü": "üê∏", "üê∏": "ü¶ü", "ü¶ü": "üßë" };

    let board = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));
    let score = 0;
    let nextPiece = null;

    function getSizeClass(emoji) {
      const sizeMap = {
        "üßë": "size-human",
        "üêü": "size-fish",
        "üê∏": "size-frog",
        "ü¶ü": "size-mosquito"
      };
      return sizeMap[emoji] || "";
    }

    function updateBoardUI() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          const piece = board[r][c];
          if (!piece) {
            cell.innerHTML = "";
          } else if (piece.color) {
            const sizeClass = getSizeClass(piece.color);
            cell.innerHTML = `<span class="creature ${sizeClass}">${piece.color}</span>${piece.direction}`;
          } else if (piece.action) {
            cell.innerHTML = piece.action;
          }
        }
      }
    }

    function applyAction(r, c, action) {
      const piece = board[r][c];
      if (!piece || !piece.color) return [r, c];

      if (action === "‚Üª") {
        piece.direction = rotate(piece.direction, 1);
        return [r, c];
      } else if (action === "‚Ü∫") {
        piece.direction = rotate(piece.direction, -1);
        return [r, c];
      } else {
        // Movement arrows: move piece AND change its direction
        const move = { "‚Üë": [-1, 0], "‚Üí": [0, 1], "‚Üì": [1, 0], "‚Üê": [0, -1] }[action];
        const nr = r + move[0];
        const nc = c + move[1];
        if (inBounds(nr, nc)) {
          const target = board[nr][nc];
          const canEat = target && target.color === eatRules[piece.color];
          
          if (canEat) {
            // If target can be eaten, just rotate to face it
            // Let the eating logic handle the actual movement with animation/scoring
            piece.direction = action;
            return [r, c];
          } else if (target === null) {
            // Only move if space is empty
            piece.direction = action;
            board[nr][nc] = piece;
            board[r][c] = null;
            return [nr, nc];
          }
        }
        return [r, c];
      }
    }

    function rotate(dir, delta) {
      const idx = directions.indexOf(dir);
      return directions[(idx + delta + 4) % 4];
    }

    function inBounds(r, c) {
      return r >= 0 && r < boardSize && c >= 0 && c < boardSize;
    }

    function highlightCell(r, c, className) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.classList.add(className);
      }
    }

    function unhighlightCell(r, c, className) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.classList.remove(className);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function showMultiplierPopup(r, c, chainLength, points) {
      const cellPos = getCellPosition(r, c);
      const popup = document.createElement('div');
      popup.className = 'multiplier-popup';
      popup.textContent = `${chainLength}x = ${points} pts!`;
      popup.style.left = cellPos.left + 'px';
      popup.style.top = cellPos.top + 'px';
      boardElem.appendChild(popup);
      
      setTimeout(() => popup.remove(), 1500);
    }

    function createConfetti(r, c, count) {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500'];
      const cellPos = getCellPosition(r, c);
      
      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = (cellPos.left + 30 + (Math.random() - 0.5) * 40) + 'px';
        confetti.style.top = (cellPos.top + 30) + 'px';
        confetti.style.animationDelay = (Math.random() * 0.3) + 's';
        confetti.style.transform = `translateX(${(Math.random() - 0.5) * 200}px)`;
        boardElem.appendChild(confetti);
        
        setTimeout(() => confetti.remove(), 2000);
      }
    }

    async function flashMatch(r, c) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.classList.add('match-found');
        await sleep(500);
        cell.classList.remove('match-found');
      }
    }

    async function placePiece(r, c) {
      if (!nextPiece) return;
      const cell = board[r][c];
      let placedPos = null;
      
      if (nextPiece.color && !cell) {
        board[r][c] = { ...nextPiece };
        placedPos = [r, c];
      } else if (nextPiece.action && cell && cell.color) {
        placedPos = applyAction(r, c, nextPiece.action);
      } else {
        return;
      }

      updateBoardUI();
      await checkAllEats(placedPos);
      nextPiece = generateNextPiece();
      scoreDisplay.textContent = score;
      updateBoardUI();
      nextPieceDisplay.innerHTML = displayPiece(nextPiece);

      if (isBoardFull()) {
        alert("Game Over! Final Score: " + score);
        resetGame();
      }
    }

    async function checkAllEats(startPos) {
      if (!startPos) return; // No position to check
      
      let lastAnimatedPos = startPos;
      let keepChecking = true;
      let totalChainLength = 0;
      let finalPos = startPos;

      while (keepChecking) {
        keepChecking = false;
        
        if (lastAnimatedPos) {
          const [r, c] = lastAnimatedPos;
          highlightCell(r, c, 'checking');
          await sleep(125);
          
          const eatResult = await tryEat(r, c, false); // Don't celebrate yet
          unhighlightCell(r, c, 'checking');
          
          if (eatResult) {
            totalChainLength += eatResult.chainLength;
            lastAnimatedPos = eatResult.pos;
            finalPos = eatResult.pos;
            keepChecking = true;
            continue;
          }
        }

        if (lastAnimatedPos) {
          const [r, c] = lastAnimatedPos;
          const clockwiseOffsets = [[-1, 0], [0, 1], [1, 0], [0, -1]];
          
          for (let [dr, dc] of clockwiseOffsets) {
            const nr = r + dr, nc = c + dc;
            if (inBounds(nr, nc)) {
              highlightCell(nr, nc, 'checking');
              await sleep(125);
              unhighlightCell(nr, nc, 'checking');
            }
          }
          
          for (let [dr, dc] of clockwiseOffsets) {
            const nr = r + dr, nc = c + dc;
            if (inBounds(nr, nc)) {
              const eatResult = await tryEat(nr, nc, false); // Don't celebrate yet
              
              if (eatResult) {
                totalChainLength += eatResult.chainLength;
                lastAnimatedPos = eatResult.pos;
                finalPos = eatResult.pos;
                keepChecking = true;
                break;
              }
            }
          }
        }
      }
      
      // Now celebrate the TOTAL chain at the end
      if (totalChainLength > 0) {
        const points = totalChainLength * totalChainLength;
        score += points;
        
        if (totalChainLength >= 3) {
          showMultiplierPopup(finalPos[0], finalPos[1], totalChainLength, points);
          const confettiCount = Math.min(totalChainLength * 5, 30);
          createConfetti(finalPos[0], finalPos[1], confettiCount);
        } else if (totalChainLength === 2) {
          showMultiplierPopup(finalPos[0], finalPos[1], totalChainLength, points);
        }
      }
    }

    function getCellPosition(r, c) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      const boardRect = boardElem.getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();
      return {
        left: cellRect.left - boardRect.left,
        top: cellRect.top - boardRect.top
      };
    }

    async function animateEat(fromR, fromC, toR, toC, piece) {
      return new Promise(resolve => {
        const animPiece = document.createElement('div');
        animPiece.className = 'animated-piece';
        const sizeClass = getSizeClass(piece.color);
        animPiece.innerHTML = `<span class="creature ${sizeClass}">${piece.color}</span>${piece.direction}`;
        
        const fromPos = getCellPosition(fromR, fromC);
        const toPos = getCellPosition(toR, toC);
        
        animPiece.style.left = fromPos.left + 'px';
        animPiece.style.top = fromPos.top + 'px';
        
        boardElem.appendChild(animPiece);
        
        requestAnimationFrame(() => {
          animPiece.style.left = toPos.left + 'px';
          animPiece.style.top = toPos.top + 'px';
        });
        
        setTimeout(() => {
          animPiece.remove();
          resolve();
        }, 300);
      });
    }

    async function tryEat(r, c, celebrate = true) {
      const piece = board[r][c];
      if (!piece || !piece.color) return null;
      
      // Keep eating as long as we can find valid targets
      let currentR = r;
      let currentC = c;
      let chainLength = 0;
      let ateAtLeastOnce = false;
      
      while (true) {
        // Check current direction for a target
        const [dr, dc] = { "‚Üë": [-1, 0], "‚Üí": [0, 1], "‚Üì": [1, 0], "‚Üê": [0, -1] }[piece.direction];
        const targetR = currentR + dr;
        const targetC = currentC + dc;
        
        // Check if there's a valid target
        if (!inBounds(targetR, targetC)) break;
        const target = board[targetR][targetC];
        if (!target || target.color !== eatRules[piece.color]) break;
        
        // Found a target! Eat it
        ateAtLeastOnce = true;
        chainLength++;
        
        await Promise.all([flashMatch(currentR, currentC), flashMatch(targetR, targetC)]);
        await animateEat(currentR, currentC, targetR, targetC, piece);
        
        // Inherit victim's direction IMMEDIATELY
        piece.direction = target.direction;
        
        // Move piece forward
        board[targetR][targetC] = { ...piece };
        board[currentR][currentC] = null;
        updateBoardUI();
        
        // Update current position
        currentR = targetR;
        currentC = targetC;
        
        // Now check the NEW direction for another target (loop continues)
      }
      
      if (ateAtLeastOnce) {
        return {
          pos: [currentR, currentC],
          chainLength: chainLength
        };
      }
      
      return null;
    }

    function isBoardFull() {
      return board.every(row => row.every(cell => cell !== null));
    }

    function generateNextPiece() {
      const hasCharacter = board.some(row => row.some(cell => cell && cell.color));
      if (!hasCharacter || Math.random() < 0.90) {
        return {
          color: colors[Math.floor(Math.random() * colors.length)],
          direction: directions[Math.floor(Math.random() * directions.length)]
        };
      } else {
        return {
          action: actions[Math.floor(Math.random() * actions.length)]
        };
      }
    }

    function displayPiece(piece) {
      if (piece.color) {
        const sizeClass = getSizeClass(piece.color);
        return `<span class="creature ${sizeClass}">${piece.color}</span>${piece.direction}`;
      } else {
        return piece.action;
      }
    }

    function resetGame() {
      board = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));
      score = 0;
      scoreDisplay.textContent = 0;
      nextPiece = generateNextPiece();
      nextPieceDisplay.innerHTML = displayPiece(nextPiece);
      updateBoardUI();
    }

    const boardElem = document.getElementById("board");
    const scoreDisplay = document.getElementById("score");
    const nextPieceDisplay = document.getElementById("next-piece");

    function showHoverPreview(r, c) {
      if (!nextPiece) return;
      
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      const piece = board[r][c];
      
      const isValid = (nextPiece.color && !piece) || (nextPiece.action && piece && piece.color);
      if (!isValid) return;
      
      const preview = document.createElement('div');
      preview.className = 'hover-preview';
      preview.innerHTML = displayPiece(nextPiece);
      cell.appendChild(preview);
    }

    function hideHoverPreview(r, c) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      const preview = cell.querySelector('.hover-preview');
      if (preview) {
        preview.remove();
      }
    }

    for (let r = 0; r < boardSize; r++) {
      for (let c = 0; c < boardSize; c++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.onclick = () => placePiece(r, c);
        cell.onmouseenter = () => showHoverPreview(r, c);
        cell.onmouseleave = () => hideHoverPreview(r, c);
        boardElem.appendChild(cell);
      }
    }

    resetGame();
  </script>
</body>
</html>

